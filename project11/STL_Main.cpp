////STL (Standard Template Library)
////표준 템플릿 라이브러리
////자료 구조, 함수, 알고리즘 활용에 도움을 주는 라이브러리 파일(헤더 파일)
////STL의 구성 요소
////1. 알고리즘 : 특정 로직에 대한
////2. 컨테이너 : 데이터 자료 구조(c언어의 배열처럼 동일 요소를 모아놓은 데이터 덩어리)
////                     배열과 다르게 고정된 크기가 아닌 동적으로 크기 변경이 가능
////                     순차(sequence) : 여러 개 데이터를 순번으로 저장할 수 있다.
////                      - vector(벡터) : 크기를 수정할 수 있는 배열(가변 배열)
////                      - deque(덱) : 양방향으로 데이터를 저장할 수 있는 자료구조
////                      - list(리스트) : 모든 위치에서의 추가, 삭제가 동일한 시간으로 처리되는 자료구조
////                      정렬(sorted) : 여러 개의 데이터를 key를 기반으로 찾아내며 순번이 없다.
////                      - set (셋) : 집합, 중복된 키가 허용되지 않는다.
////                      - map (맵) : 키와 데이터가 하나의 묶음으로 제공된다.
////                                      ex) 키(비밀번호) - 데이터(1234)
////                                            키는 중복이 될 수 없다.(아파트에 101호가 존재할 수 없듯.)
////3. 반복자 : 자료구조를 사용하다보면 자료구조별로 문법이 달라 여러 개를 사용하기 불편한 문제가 있음.
////                  따라서 자료구조 전체에서 사용할 수 있도록 반복자 (iterator)를 제공하고 있음.
////                  반복자 = 포인터
//
//#include <iostream>
//#include <vector>
//using namespace std;
//
//int main()
//{
//	//벡터 만들기
//	//vector<데이터타입> 변수명 ;
//	vector<int> v1; //비어있는 벡터 생성
//	vector<int> v2(10); // "{0,0,0,0,0,0,0,0,0,0}
//	vector<int> v3(10, 1); //{1,1,1,1,1,1,1,1,1,1}
//	vector<int> v4(v3); //{1,1,1,1,1,1,1,1,1,1}
//
//	//vector 접근 방법
//	cout << v2[0] << endl; //배열의 인덱스와 동일하게 사용
//	cout << v3.at(1) << endl; //벡터의 1번째 값 참조(범위를 넘을 경우에 대한 방지가 되어있음. 위 방식보단 느림)
//	cout << v4.front() << endl; //벡터의 첫번째 데이터를 참조한다.
//	cout << v4.back() << endl; //벡터의 마지막 데이터를 참조한다.
//
//	//vector에 데이터 추가 / 삭제하는 방법
//	for (int i = 0; i < 10; i++)
//	{
//		v1.push_back(i);
//	}
//
//
//	//iterator를 이용한 출력
//	vector<int>::iterator iter; //반복자 선언
//	iter = v1.begin();//반복자는 v1의 시작 위치로 설정된다.
//
//	iter = v1.insert(iter + 5, 17);
//	//해당 반복자를 통해 v1의 5번째 위치에 17의 값을 추가한다.
//
//	iter = v1.insert(iter, 5, 4);
//	//지정한 반복자 위치를 기준으로 4가 5번 순차적으로 들어간다.
//
//	int arr[] = { 5,50,500,5000 };
//	iter = v1.insert(v1.begin(), arr, arr + 4);
//	//v1의 시작 지점에서 (배열의 첫번째 값이 있는 위치)에서 4칸까지 작업한다.
//
//	v1.erase(v1.begin() + 1, v1.begin() + 4); //인덱스 1~3까지 삭제
//
//	//반복자는 v1의 시작 위치로 설정되며 (1회)
//	//반복자가 v1의 마지막 부분이 아닐때까지 반복을 진행한다.
//	//반복자가 가리키고 있는 값을 출력한다.(포인터 참조연산자(*))
//	//반복자의 값을 1 증가한다. (포인터에서 1을 더할 경우, 그 다음 칸을 가리키게 된다.(포인터와 배열))
//	for (iter = v1.begin(); iter != v1.end(); iter++)
//		cout << *iter << " ";
//
//	//자료 구조에서 쓰는 for문
//	vector<string> item_list;
//	item_list.push_back("어묵");
//	item_list.push_back("떡볶이");
//	item_list.push_back("순대");
//	item_list.push_back("라면");
//
//	//for(auto 변수명 : 배열 / 자료구조)로 적을 경우 순차적으로 데이터를 반복해 표현한다.
//
//	for (auto item : item_list)
//	{
//		cout << item << endl;
//	}
//
//
//	return 0;
//}